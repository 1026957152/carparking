// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: test.proto

#ifndef PROTOBUF_test_2eproto__INCLUDED
#define PROTOBUF_test_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_test_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[13];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsHelloRequestImpl();
void InitDefaultsHelloRequest();
void InitDefaultsHelloReplyImpl();
void InitDefaultsHelloReply();
void InitDefaultsRouteSummaryImpl();
void InitDefaultsRouteSummary();
void InitDefaultsPointImpl();
void InitDefaultsPoint();
void InitDefaultsRectangleImpl();
void InitDefaultsRectangle();
void InitDefaultsFeatureImpl();
void InitDefaultsFeature();
void InitDefaultsFeatureDatabaseImpl();
void InitDefaultsFeatureDatabase();
void InitDefaultsRouteNoteImpl();
void InitDefaultsRouteNote();
void InitDefaultsAlertImpl();
void InitDefaultsAlert();
void InitDefaultsModeImpl();
void InitDefaultsMode();
void InitDefaultsTempImpl();
void InitDefaultsTemp();
void InitDefaultsTopicImpl();
void InitDefaultsTopic();
void InitDefaultsNotificationImpl();
void InitDefaultsNotification();
inline void InitDefaults() {
  InitDefaultsHelloRequest();
  InitDefaultsHelloReply();
  InitDefaultsRouteSummary();
  InitDefaultsPoint();
  InitDefaultsRectangle();
  InitDefaultsFeature();
  InitDefaultsFeatureDatabase();
  InitDefaultsRouteNote();
  InitDefaultsAlert();
  InitDefaultsMode();
  InitDefaultsTemp();
  InitDefaultsTopic();
  InitDefaultsNotification();
}
}  // namespace protobuf_test_2eproto
namespace grpc {
class Alert;
class AlertDefaultTypeInternal;
extern AlertDefaultTypeInternal _Alert_default_instance_;
class Feature;
class FeatureDefaultTypeInternal;
extern FeatureDefaultTypeInternal _Feature_default_instance_;
class FeatureDatabase;
class FeatureDatabaseDefaultTypeInternal;
extern FeatureDatabaseDefaultTypeInternal _FeatureDatabase_default_instance_;
class HelloReply;
class HelloReplyDefaultTypeInternal;
extern HelloReplyDefaultTypeInternal _HelloReply_default_instance_;
class HelloRequest;
class HelloRequestDefaultTypeInternal;
extern HelloRequestDefaultTypeInternal _HelloRequest_default_instance_;
class Mode;
class ModeDefaultTypeInternal;
extern ModeDefaultTypeInternal _Mode_default_instance_;
class Notification;
class NotificationDefaultTypeInternal;
extern NotificationDefaultTypeInternal _Notification_default_instance_;
class Point;
class PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class Rectangle;
class RectangleDefaultTypeInternal;
extern RectangleDefaultTypeInternal _Rectangle_default_instance_;
class RouteNote;
class RouteNoteDefaultTypeInternal;
extern RouteNoteDefaultTypeInternal _RouteNote_default_instance_;
class RouteSummary;
class RouteSummaryDefaultTypeInternal;
extern RouteSummaryDefaultTypeInternal _RouteSummary_default_instance_;
class Temp;
class TempDefaultTypeInternal;
extern TempDefaultTypeInternal _Temp_default_instance_;
class Topic;
class TopicDefaultTypeInternal;
extern TopicDefaultTypeInternal _Topic_default_instance_;
}  // namespace grpc
namespace grpc {

enum topicType {
  ALERT = 0,
  MODE = 1,
  TEMP = 2,
  topicType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  topicType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool topicType_IsValid(int value);
const topicType topicType_MIN = ALERT;
const topicType topicType_MAX = TEMP;
const int topicType_ARRAYSIZE = topicType_MAX + 1;

const ::google::protobuf::EnumDescriptor* topicType_descriptor();
inline const ::std::string& topicType_Name(topicType value) {
  return ::google::protobuf::internal::NameOfEnum(
    topicType_descriptor(), value);
}
inline bool topicType_Parse(
    const ::std::string& name, topicType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<topicType>(
    topicType_descriptor(), name, value);
}
// ===================================================================

class HelloRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:grpc.HelloRequest) */ {
 public:
  HelloRequest();
  virtual ~HelloRequest();

  HelloRequest(const HelloRequest& from);

  inline HelloRequest& operator=(const HelloRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HelloRequest(HelloRequest&& from) noexcept
    : HelloRequest() {
    *this = ::std::move(from);
  }

  inline HelloRequest& operator=(HelloRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HelloRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HelloRequest* internal_default_instance() {
    return reinterpret_cast<const HelloRequest*>(
               &_HelloRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(HelloRequest* other);
  friend void swap(HelloRequest& a, HelloRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HelloRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  HelloRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HelloRequest& from);
  void MergeFrom(const HelloRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HelloRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string sex = 2;
  void clear_sex();
  static const int kSexFieldNumber = 2;
  const ::std::string& sex() const;
  void set_sex(const ::std::string& value);
  #if LANG_CXX11
  void set_sex(::std::string&& value);
  #endif
  void set_sex(const char* value);
  void set_sex(const char* value, size_t size);
  ::std::string* mutable_sex();
  ::std::string* release_sex();
  void set_allocated_sex(::std::string* sex);

  // @@protoc_insertion_point(class_scope:grpc.HelloRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr sex_;
  mutable int _cached_size_;
  friend struct ::protobuf_test_2eproto::TableStruct;
  friend void ::protobuf_test_2eproto::InitDefaultsHelloRequestImpl();
};
// -------------------------------------------------------------------

class HelloReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:grpc.HelloReply) */ {
 public:
  HelloReply();
  virtual ~HelloReply();

  HelloReply(const HelloReply& from);

  inline HelloReply& operator=(const HelloReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HelloReply(HelloReply&& from) noexcept
    : HelloReply() {
    *this = ::std::move(from);
  }

  inline HelloReply& operator=(HelloReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HelloReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HelloReply* internal_default_instance() {
    return reinterpret_cast<const HelloReply*>(
               &_HelloReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(HelloReply* other);
  friend void swap(HelloReply& a, HelloReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HelloReply* New() const PROTOBUF_FINAL { return New(NULL); }

  HelloReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HelloReply& from);
  void MergeFrom(const HelloReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HelloReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 1;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:grpc.HelloReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  mutable int _cached_size_;
  friend struct ::protobuf_test_2eproto::TableStruct;
  friend void ::protobuf_test_2eproto::InitDefaultsHelloReplyImpl();
};
// -------------------------------------------------------------------

class RouteSummary : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:grpc.RouteSummary) */ {
 public:
  RouteSummary();
  virtual ~RouteSummary();

  RouteSummary(const RouteSummary& from);

  inline RouteSummary& operator=(const RouteSummary& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RouteSummary(RouteSummary&& from) noexcept
    : RouteSummary() {
    *this = ::std::move(from);
  }

  inline RouteSummary& operator=(RouteSummary&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RouteSummary& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RouteSummary* internal_default_instance() {
    return reinterpret_cast<const RouteSummary*>(
               &_RouteSummary_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(RouteSummary* other);
  friend void swap(RouteSummary& a, RouteSummary& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RouteSummary* New() const PROTOBUF_FINAL { return New(NULL); }

  RouteSummary* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RouteSummary& from);
  void MergeFrom(const RouteSummary& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RouteSummary* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 point_count = 1;
  void clear_point_count();
  static const int kPointCountFieldNumber = 1;
  ::google::protobuf::int32 point_count() const;
  void set_point_count(::google::protobuf::int32 value);

  // int32 feture_count = 2;
  void clear_feture_count();
  static const int kFetureCountFieldNumber = 2;
  ::google::protobuf::int32 feture_count() const;
  void set_feture_count(::google::protobuf::int32 value);

  // int32 distance = 3;
  void clear_distance();
  static const int kDistanceFieldNumber = 3;
  ::google::protobuf::int32 distance() const;
  void set_distance(::google::protobuf::int32 value);

  // int32 elapsed_time = 4;
  void clear_elapsed_time();
  static const int kElapsedTimeFieldNumber = 4;
  ::google::protobuf::int32 elapsed_time() const;
  void set_elapsed_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:grpc.RouteSummary)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 point_count_;
  ::google::protobuf::int32 feture_count_;
  ::google::protobuf::int32 distance_;
  ::google::protobuf::int32 elapsed_time_;
  mutable int _cached_size_;
  friend struct ::protobuf_test_2eproto::TableStruct;
  friend void ::protobuf_test_2eproto::InitDefaultsRouteSummaryImpl();
};
// -------------------------------------------------------------------

class Point : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:grpc.Point) */ {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(Point&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Point& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Point* other);
  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Point* New() const PROTOBUF_FINAL { return New(NULL); }

  Point* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Point* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 latitude = 1;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 1;
  ::google::protobuf::int32 latitude() const;
  void set_latitude(::google::protobuf::int32 value);

  // int32 longitude = 2;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 2;
  ::google::protobuf::int32 longitude() const;
  void set_longitude(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:grpc.Point)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 latitude_;
  ::google::protobuf::int32 longitude_;
  mutable int _cached_size_;
  friend struct ::protobuf_test_2eproto::TableStruct;
  friend void ::protobuf_test_2eproto::InitDefaultsPointImpl();
};
// -------------------------------------------------------------------

class Rectangle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:grpc.Rectangle) */ {
 public:
  Rectangle();
  virtual ~Rectangle();

  Rectangle(const Rectangle& from);

  inline Rectangle& operator=(const Rectangle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Rectangle(Rectangle&& from) noexcept
    : Rectangle() {
    *this = ::std::move(from);
  }

  inline Rectangle& operator=(Rectangle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Rectangle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Rectangle* internal_default_instance() {
    return reinterpret_cast<const Rectangle*>(
               &_Rectangle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Rectangle* other);
  friend void swap(Rectangle& a, Rectangle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Rectangle* New() const PROTOBUF_FINAL { return New(NULL); }

  Rectangle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Rectangle& from);
  void MergeFrom(const Rectangle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Rectangle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .grpc.Point lo = 1;
  bool has_lo() const;
  void clear_lo();
  static const int kLoFieldNumber = 1;
  const ::grpc::Point& lo() const;
  ::grpc::Point* release_lo();
  ::grpc::Point* mutable_lo();
  void set_allocated_lo(::grpc::Point* lo);

  // .grpc.Point hi = 2;
  bool has_hi() const;
  void clear_hi();
  static const int kHiFieldNumber = 2;
  const ::grpc::Point& hi() const;
  ::grpc::Point* release_hi();
  ::grpc::Point* mutable_hi();
  void set_allocated_hi(::grpc::Point* hi);

  // @@protoc_insertion_point(class_scope:grpc.Rectangle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::grpc::Point* lo_;
  ::grpc::Point* hi_;
  mutable int _cached_size_;
  friend struct ::protobuf_test_2eproto::TableStruct;
  friend void ::protobuf_test_2eproto::InitDefaultsRectangleImpl();
};
// -------------------------------------------------------------------

class Feature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:grpc.Feature) */ {
 public:
  Feature();
  virtual ~Feature();

  Feature(const Feature& from);

  inline Feature& operator=(const Feature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Feature(Feature&& from) noexcept
    : Feature() {
    *this = ::std::move(from);
  }

  inline Feature& operator=(Feature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Feature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Feature* internal_default_instance() {
    return reinterpret_cast<const Feature*>(
               &_Feature_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Feature* other);
  friend void swap(Feature& a, Feature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Feature* New() const PROTOBUF_FINAL { return New(NULL); }

  Feature* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Feature& from);
  void MergeFrom(const Feature& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Feature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .grpc.Point location = 2;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 2;
  const ::grpc::Point& location() const;
  ::grpc::Point* release_location();
  ::grpc::Point* mutable_location();
  void set_allocated_location(::grpc::Point* location);

  // @@protoc_insertion_point(class_scope:grpc.Feature)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::grpc::Point* location_;
  mutable int _cached_size_;
  friend struct ::protobuf_test_2eproto::TableStruct;
  friend void ::protobuf_test_2eproto::InitDefaultsFeatureImpl();
};
// -------------------------------------------------------------------

class FeatureDatabase : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:grpc.FeatureDatabase) */ {
 public:
  FeatureDatabase();
  virtual ~FeatureDatabase();

  FeatureDatabase(const FeatureDatabase& from);

  inline FeatureDatabase& operator=(const FeatureDatabase& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FeatureDatabase(FeatureDatabase&& from) noexcept
    : FeatureDatabase() {
    *this = ::std::move(from);
  }

  inline FeatureDatabase& operator=(FeatureDatabase&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FeatureDatabase& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FeatureDatabase* internal_default_instance() {
    return reinterpret_cast<const FeatureDatabase*>(
               &_FeatureDatabase_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(FeatureDatabase* other);
  friend void swap(FeatureDatabase& a, FeatureDatabase& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FeatureDatabase* New() const PROTOBUF_FINAL { return New(NULL); }

  FeatureDatabase* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FeatureDatabase& from);
  void MergeFrom(const FeatureDatabase& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FeatureDatabase* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .grpc.Feature feature = 1;
  int feature_size() const;
  void clear_feature();
  static const int kFeatureFieldNumber = 1;
  const ::grpc::Feature& feature(int index) const;
  ::grpc::Feature* mutable_feature(int index);
  ::grpc::Feature* add_feature();
  ::google::protobuf::RepeatedPtrField< ::grpc::Feature >*
      mutable_feature();
  const ::google::protobuf::RepeatedPtrField< ::grpc::Feature >&
      feature() const;

  // @@protoc_insertion_point(class_scope:grpc.FeatureDatabase)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::grpc::Feature > feature_;
  mutable int _cached_size_;
  friend struct ::protobuf_test_2eproto::TableStruct;
  friend void ::protobuf_test_2eproto::InitDefaultsFeatureDatabaseImpl();
};
// -------------------------------------------------------------------

class RouteNote : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:grpc.RouteNote) */ {
 public:
  RouteNote();
  virtual ~RouteNote();

  RouteNote(const RouteNote& from);

  inline RouteNote& operator=(const RouteNote& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RouteNote(RouteNote&& from) noexcept
    : RouteNote() {
    *this = ::std::move(from);
  }

  inline RouteNote& operator=(RouteNote&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RouteNote& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RouteNote* internal_default_instance() {
    return reinterpret_cast<const RouteNote*>(
               &_RouteNote_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(RouteNote* other);
  friend void swap(RouteNote& a, RouteNote& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RouteNote* New() const PROTOBUF_FINAL { return New(NULL); }

  RouteNote* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RouteNote& from);
  void MergeFrom(const RouteNote& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RouteNote* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // .grpc.Point location = 1;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::grpc::Point& location() const;
  ::grpc::Point* release_location();
  ::grpc::Point* mutable_location();
  void set_allocated_location(::grpc::Point* location);

  // @@protoc_insertion_point(class_scope:grpc.RouteNote)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::grpc::Point* location_;
  mutable int _cached_size_;
  friend struct ::protobuf_test_2eproto::TableStruct;
  friend void ::protobuf_test_2eproto::InitDefaultsRouteNoteImpl();
};
// -------------------------------------------------------------------

class Alert : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:grpc.Alert) */ {
 public:
  Alert();
  virtual ~Alert();

  Alert(const Alert& from);

  inline Alert& operator=(const Alert& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Alert(Alert&& from) noexcept
    : Alert() {
    *this = ::std::move(from);
  }

  inline Alert& operator=(Alert&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Alert& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Alert* internal_default_instance() {
    return reinterpret_cast<const Alert*>(
               &_Alert_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Alert* other);
  friend void swap(Alert& a, Alert& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Alert* New() const PROTOBUF_FINAL { return New(NULL); }

  Alert* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Alert& from);
  void MergeFrom(const Alert& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Alert* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 1;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:grpc.Alert)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  mutable int _cached_size_;
  friend struct ::protobuf_test_2eproto::TableStruct;
  friend void ::protobuf_test_2eproto::InitDefaultsAlertImpl();
};
// -------------------------------------------------------------------

class Mode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:grpc.Mode) */ {
 public:
  Mode();
  virtual ~Mode();

  Mode(const Mode& from);

  inline Mode& operator=(const Mode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Mode(Mode&& from) noexcept
    : Mode() {
    *this = ::std::move(from);
  }

  inline Mode& operator=(Mode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Mode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Mode* internal_default_instance() {
    return reinterpret_cast<const Mode*>(
               &_Mode_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Mode* other);
  friend void swap(Mode& a, Mode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Mode* New() const PROTOBUF_FINAL { return New(NULL); }

  Mode* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Mode& from);
  void MergeFrom(const Mode& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Mode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string newMode = 1;
  void clear_newmode();
  static const int kNewModeFieldNumber = 1;
  const ::std::string& newmode() const;
  void set_newmode(const ::std::string& value);
  #if LANG_CXX11
  void set_newmode(::std::string&& value);
  #endif
  void set_newmode(const char* value);
  void set_newmode(const char* value, size_t size);
  ::std::string* mutable_newmode();
  ::std::string* release_newmode();
  void set_allocated_newmode(::std::string* newmode);

  // @@protoc_insertion_point(class_scope:grpc.Mode)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr newmode_;
  mutable int _cached_size_;
  friend struct ::protobuf_test_2eproto::TableStruct;
  friend void ::protobuf_test_2eproto::InitDefaultsModeImpl();
};
// -------------------------------------------------------------------

class Temp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:grpc.Temp) */ {
 public:
  Temp();
  virtual ~Temp();

  Temp(const Temp& from);

  inline Temp& operator=(const Temp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Temp(Temp&& from) noexcept
    : Temp() {
    *this = ::std::move(from);
  }

  inline Temp& operator=(Temp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Temp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Temp* internal_default_instance() {
    return reinterpret_cast<const Temp*>(
               &_Temp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(Temp* other);
  friend void swap(Temp& a, Temp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Temp* New() const PROTOBUF_FINAL { return New(NULL); }

  Temp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Temp& from);
  void MergeFrom(const Temp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Temp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 newTemp = 1;
  void clear_newtemp();
  static const int kNewTempFieldNumber = 1;
  ::google::protobuf::uint32 newtemp() const;
  void set_newtemp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:grpc.Temp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 newtemp_;
  mutable int _cached_size_;
  friend struct ::protobuf_test_2eproto::TableStruct;
  friend void ::protobuf_test_2eproto::InitDefaultsTempImpl();
};
// -------------------------------------------------------------------

class Topic : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:grpc.Topic) */ {
 public:
  Topic();
  virtual ~Topic();

  Topic(const Topic& from);

  inline Topic& operator=(const Topic& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Topic(Topic&& from) noexcept
    : Topic() {
    *this = ::std::move(from);
  }

  inline Topic& operator=(Topic&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Topic& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Topic* internal_default_instance() {
    return reinterpret_cast<const Topic*>(
               &_Topic_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(Topic* other);
  friend void swap(Topic& a, Topic& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Topic* New() const PROTOBUF_FINAL { return New(NULL); }

  Topic* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Topic& from);
  void MergeFrom(const Topic& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Topic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string clientName = 1;
  void clear_clientname();
  static const int kClientNameFieldNumber = 1;
  const ::std::string& clientname() const;
  void set_clientname(const ::std::string& value);
  #if LANG_CXX11
  void set_clientname(::std::string&& value);
  #endif
  void set_clientname(const char* value);
  void set_clientname(const char* value, size_t size);
  ::std::string* mutable_clientname();
  ::std::string* release_clientname();
  void set_allocated_clientname(::std::string* clientname);

  // .grpc.topicType type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::grpc::topicType type() const;
  void set_type(::grpc::topicType value);

  // @@protoc_insertion_point(class_scope:grpc.Topic)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr clientname_;
  int type_;
  mutable int _cached_size_;
  friend struct ::protobuf_test_2eproto::TableStruct;
  friend void ::protobuf_test_2eproto::InitDefaultsTopicImpl();
};
// -------------------------------------------------------------------

class Notification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:grpc.Notification) */ {
 public:
  Notification();
  virtual ~Notification();

  Notification(const Notification& from);

  inline Notification& operator=(const Notification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Notification(Notification&& from) noexcept
    : Notification() {
    *this = ::std::move(from);
  }

  inline Notification& operator=(Notification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Notification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Notification* internal_default_instance() {
    return reinterpret_cast<const Notification*>(
               &_Notification_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(Notification* other);
  friend void swap(Notification& a, Notification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Notification* New() const PROTOBUF_FINAL { return New(NULL); }

  Notification* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Notification& from);
  void MergeFrom(const Notification& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Notification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string clientName = 1;
  void clear_clientname();
  static const int kClientNameFieldNumber = 1;
  const ::std::string& clientname() const;
  void set_clientname(const ::std::string& value);
  #if LANG_CXX11
  void set_clientname(::std::string&& value);
  #endif
  void set_clientname(const char* value);
  void set_clientname(const char* value, size_t size);
  ::std::string* mutable_clientname();
  ::std::string* release_clientname();
  void set_allocated_clientname(::std::string* clientname);

  // string serverName = 2;
  void clear_servername();
  static const int kServerNameFieldNumber = 2;
  const ::std::string& servername() const;
  void set_servername(const ::std::string& value);
  #if LANG_CXX11
  void set_servername(::std::string&& value);
  #endif
  void set_servername(const char* value);
  void set_servername(const char* value, size_t size);
  ::std::string* mutable_servername();
  ::std::string* release_servername();
  void set_allocated_servername(::std::string* servername);

  // .grpc.Mode m = 4;
  bool has_m() const;
  void clear_m();
  static const int kMFieldNumber = 4;
  const ::grpc::Mode& m() const;
  ::grpc::Mode* release_m();
  ::grpc::Mode* mutable_m();
  void set_allocated_m(::grpc::Mode* m);

  // .grpc.Temp t = 5;
  bool has_t() const;
  void clear_t();
  static const int kTFieldNumber = 5;
  const ::grpc::Temp& t() const;
  ::grpc::Temp* release_t();
  ::grpc::Temp* mutable_t();
  void set_allocated_t(::grpc::Temp* t);

  // .grpc.Alert a = 6;
  bool has_a() const;
  void clear_a();
  static const int kAFieldNumber = 6;
  const ::grpc::Alert& a() const;
  ::grpc::Alert* release_a();
  ::grpc::Alert* mutable_a();
  void set_allocated_a(::grpc::Alert* a);

  // .grpc.topicType type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::grpc::topicType type() const;
  void set_type(::grpc::topicType value);

  // @@protoc_insertion_point(class_scope:grpc.Notification)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr clientname_;
  ::google::protobuf::internal::ArenaStringPtr servername_;
  ::grpc::Mode* m_;
  ::grpc::Temp* t_;
  ::grpc::Alert* a_;
  int type_;
  mutable int _cached_size_;
  friend struct ::protobuf_test_2eproto::TableStruct;
  friend void ::protobuf_test_2eproto::InitDefaultsNotificationImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HelloRequest

// string name = 1;
inline void HelloRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HelloRequest::name() const {
  // @@protoc_insertion_point(field_get:grpc.HelloRequest.name)
  return name_.GetNoArena();
}
inline void HelloRequest::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:grpc.HelloRequest.name)
}
#if LANG_CXX11
inline void HelloRequest::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:grpc.HelloRequest.name)
}
#endif
inline void HelloRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:grpc.HelloRequest.name)
}
inline void HelloRequest::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:grpc.HelloRequest.name)
}
inline ::std::string* HelloRequest::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:grpc.HelloRequest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HelloRequest::release_name() {
  // @@protoc_insertion_point(field_release:grpc.HelloRequest.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HelloRequest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:grpc.HelloRequest.name)
}

// string sex = 2;
inline void HelloRequest::clear_sex() {
  sex_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HelloRequest::sex() const {
  // @@protoc_insertion_point(field_get:grpc.HelloRequest.sex)
  return sex_.GetNoArena();
}
inline void HelloRequest::set_sex(const ::std::string& value) {
  
  sex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:grpc.HelloRequest.sex)
}
#if LANG_CXX11
inline void HelloRequest::set_sex(::std::string&& value) {
  
  sex_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:grpc.HelloRequest.sex)
}
#endif
inline void HelloRequest::set_sex(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:grpc.HelloRequest.sex)
}
inline void HelloRequest::set_sex(const char* value, size_t size) {
  
  sex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:grpc.HelloRequest.sex)
}
inline ::std::string* HelloRequest::mutable_sex() {
  
  // @@protoc_insertion_point(field_mutable:grpc.HelloRequest.sex)
  return sex_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HelloRequest::release_sex() {
  // @@protoc_insertion_point(field_release:grpc.HelloRequest.sex)
  
  return sex_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HelloRequest::set_allocated_sex(::std::string* sex) {
  if (sex != NULL) {
    
  } else {
    
  }
  sex_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sex);
  // @@protoc_insertion_point(field_set_allocated:grpc.HelloRequest.sex)
}

// -------------------------------------------------------------------

// HelloReply

// string message = 1;
inline void HelloReply::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HelloReply::message() const {
  // @@protoc_insertion_point(field_get:grpc.HelloReply.message)
  return message_.GetNoArena();
}
inline void HelloReply::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:grpc.HelloReply.message)
}
#if LANG_CXX11
inline void HelloReply::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:grpc.HelloReply.message)
}
#endif
inline void HelloReply::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:grpc.HelloReply.message)
}
inline void HelloReply::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:grpc.HelloReply.message)
}
inline ::std::string* HelloReply::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:grpc.HelloReply.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HelloReply::release_message() {
  // @@protoc_insertion_point(field_release:grpc.HelloReply.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HelloReply::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:grpc.HelloReply.message)
}

// -------------------------------------------------------------------

// RouteSummary

// int32 point_count = 1;
inline void RouteSummary::clear_point_count() {
  point_count_ = 0;
}
inline ::google::protobuf::int32 RouteSummary::point_count() const {
  // @@protoc_insertion_point(field_get:grpc.RouteSummary.point_count)
  return point_count_;
}
inline void RouteSummary::set_point_count(::google::protobuf::int32 value) {
  
  point_count_ = value;
  // @@protoc_insertion_point(field_set:grpc.RouteSummary.point_count)
}

// int32 feture_count = 2;
inline void RouteSummary::clear_feture_count() {
  feture_count_ = 0;
}
inline ::google::protobuf::int32 RouteSummary::feture_count() const {
  // @@protoc_insertion_point(field_get:grpc.RouteSummary.feture_count)
  return feture_count_;
}
inline void RouteSummary::set_feture_count(::google::protobuf::int32 value) {
  
  feture_count_ = value;
  // @@protoc_insertion_point(field_set:grpc.RouteSummary.feture_count)
}

// int32 distance = 3;
inline void RouteSummary::clear_distance() {
  distance_ = 0;
}
inline ::google::protobuf::int32 RouteSummary::distance() const {
  // @@protoc_insertion_point(field_get:grpc.RouteSummary.distance)
  return distance_;
}
inline void RouteSummary::set_distance(::google::protobuf::int32 value) {
  
  distance_ = value;
  // @@protoc_insertion_point(field_set:grpc.RouteSummary.distance)
}

// int32 elapsed_time = 4;
inline void RouteSummary::clear_elapsed_time() {
  elapsed_time_ = 0;
}
inline ::google::protobuf::int32 RouteSummary::elapsed_time() const {
  // @@protoc_insertion_point(field_get:grpc.RouteSummary.elapsed_time)
  return elapsed_time_;
}
inline void RouteSummary::set_elapsed_time(::google::protobuf::int32 value) {
  
  elapsed_time_ = value;
  // @@protoc_insertion_point(field_set:grpc.RouteSummary.elapsed_time)
}

// -------------------------------------------------------------------

// Point

// int32 latitude = 1;
inline void Point::clear_latitude() {
  latitude_ = 0;
}
inline ::google::protobuf::int32 Point::latitude() const {
  // @@protoc_insertion_point(field_get:grpc.Point.latitude)
  return latitude_;
}
inline void Point::set_latitude(::google::protobuf::int32 value) {
  
  latitude_ = value;
  // @@protoc_insertion_point(field_set:grpc.Point.latitude)
}

// int32 longitude = 2;
inline void Point::clear_longitude() {
  longitude_ = 0;
}
inline ::google::protobuf::int32 Point::longitude() const {
  // @@protoc_insertion_point(field_get:grpc.Point.longitude)
  return longitude_;
}
inline void Point::set_longitude(::google::protobuf::int32 value) {
  
  longitude_ = value;
  // @@protoc_insertion_point(field_set:grpc.Point.longitude)
}

// -------------------------------------------------------------------

// Rectangle

// .grpc.Point lo = 1;
inline bool Rectangle::has_lo() const {
  return this != internal_default_instance() && lo_ != NULL;
}
inline void Rectangle::clear_lo() {
  if (GetArenaNoVirtual() == NULL && lo_ != NULL) {
    delete lo_;
  }
  lo_ = NULL;
}
inline const ::grpc::Point& Rectangle::lo() const {
  const ::grpc::Point* p = lo_;
  // @@protoc_insertion_point(field_get:grpc.Rectangle.lo)
  return p != NULL ? *p : *reinterpret_cast<const ::grpc::Point*>(
      &::grpc::_Point_default_instance_);
}
inline ::grpc::Point* Rectangle::release_lo() {
  // @@protoc_insertion_point(field_release:grpc.Rectangle.lo)
  
  ::grpc::Point* temp = lo_;
  lo_ = NULL;
  return temp;
}
inline ::grpc::Point* Rectangle::mutable_lo() {
  
  if (lo_ == NULL) {
    lo_ = new ::grpc::Point;
  }
  // @@protoc_insertion_point(field_mutable:grpc.Rectangle.lo)
  return lo_;
}
inline void Rectangle::set_allocated_lo(::grpc::Point* lo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete lo_;
  }
  if (lo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lo, submessage_arena);
    }
    
  } else {
    
  }
  lo_ = lo;
  // @@protoc_insertion_point(field_set_allocated:grpc.Rectangle.lo)
}

// .grpc.Point hi = 2;
inline bool Rectangle::has_hi() const {
  return this != internal_default_instance() && hi_ != NULL;
}
inline void Rectangle::clear_hi() {
  if (GetArenaNoVirtual() == NULL && hi_ != NULL) {
    delete hi_;
  }
  hi_ = NULL;
}
inline const ::grpc::Point& Rectangle::hi() const {
  const ::grpc::Point* p = hi_;
  // @@protoc_insertion_point(field_get:grpc.Rectangle.hi)
  return p != NULL ? *p : *reinterpret_cast<const ::grpc::Point*>(
      &::grpc::_Point_default_instance_);
}
inline ::grpc::Point* Rectangle::release_hi() {
  // @@protoc_insertion_point(field_release:grpc.Rectangle.hi)
  
  ::grpc::Point* temp = hi_;
  hi_ = NULL;
  return temp;
}
inline ::grpc::Point* Rectangle::mutable_hi() {
  
  if (hi_ == NULL) {
    hi_ = new ::grpc::Point;
  }
  // @@protoc_insertion_point(field_mutable:grpc.Rectangle.hi)
  return hi_;
}
inline void Rectangle::set_allocated_hi(::grpc::Point* hi) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete hi_;
  }
  if (hi) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      hi = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, hi, submessage_arena);
    }
    
  } else {
    
  }
  hi_ = hi;
  // @@protoc_insertion_point(field_set_allocated:grpc.Rectangle.hi)
}

// -------------------------------------------------------------------

// Feature

// string name = 1;
inline void Feature::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Feature::name() const {
  // @@protoc_insertion_point(field_get:grpc.Feature.name)
  return name_.GetNoArena();
}
inline void Feature::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:grpc.Feature.name)
}
#if LANG_CXX11
inline void Feature::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:grpc.Feature.name)
}
#endif
inline void Feature::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:grpc.Feature.name)
}
inline void Feature::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:grpc.Feature.name)
}
inline ::std::string* Feature::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:grpc.Feature.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Feature::release_name() {
  // @@protoc_insertion_point(field_release:grpc.Feature.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Feature::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:grpc.Feature.name)
}

// .grpc.Point location = 2;
inline bool Feature::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void Feature::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) {
    delete location_;
  }
  location_ = NULL;
}
inline const ::grpc::Point& Feature::location() const {
  const ::grpc::Point* p = location_;
  // @@protoc_insertion_point(field_get:grpc.Feature.location)
  return p != NULL ? *p : *reinterpret_cast<const ::grpc::Point*>(
      &::grpc::_Point_default_instance_);
}
inline ::grpc::Point* Feature::release_location() {
  // @@protoc_insertion_point(field_release:grpc.Feature.location)
  
  ::grpc::Point* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::grpc::Point* Feature::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::grpc::Point;
  }
  // @@protoc_insertion_point(field_mutable:grpc.Feature.location)
  return location_;
}
inline void Feature::set_allocated_location(::grpc::Point* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete location_;
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:grpc.Feature.location)
}

// -------------------------------------------------------------------

// FeatureDatabase

// repeated .grpc.Feature feature = 1;
inline int FeatureDatabase::feature_size() const {
  return feature_.size();
}
inline void FeatureDatabase::clear_feature() {
  feature_.Clear();
}
inline const ::grpc::Feature& FeatureDatabase::feature(int index) const {
  // @@protoc_insertion_point(field_get:grpc.FeatureDatabase.feature)
  return feature_.Get(index);
}
inline ::grpc::Feature* FeatureDatabase::mutable_feature(int index) {
  // @@protoc_insertion_point(field_mutable:grpc.FeatureDatabase.feature)
  return feature_.Mutable(index);
}
inline ::grpc::Feature* FeatureDatabase::add_feature() {
  // @@protoc_insertion_point(field_add:grpc.FeatureDatabase.feature)
  return feature_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::grpc::Feature >*
FeatureDatabase::mutable_feature() {
  // @@protoc_insertion_point(field_mutable_list:grpc.FeatureDatabase.feature)
  return &feature_;
}
inline const ::google::protobuf::RepeatedPtrField< ::grpc::Feature >&
FeatureDatabase::feature() const {
  // @@protoc_insertion_point(field_list:grpc.FeatureDatabase.feature)
  return feature_;
}

// -------------------------------------------------------------------

// RouteNote

// .grpc.Point location = 1;
inline bool RouteNote::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void RouteNote::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) {
    delete location_;
  }
  location_ = NULL;
}
inline const ::grpc::Point& RouteNote::location() const {
  const ::grpc::Point* p = location_;
  // @@protoc_insertion_point(field_get:grpc.RouteNote.location)
  return p != NULL ? *p : *reinterpret_cast<const ::grpc::Point*>(
      &::grpc::_Point_default_instance_);
}
inline ::grpc::Point* RouteNote::release_location() {
  // @@protoc_insertion_point(field_release:grpc.RouteNote.location)
  
  ::grpc::Point* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::grpc::Point* RouteNote::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::grpc::Point;
  }
  // @@protoc_insertion_point(field_mutable:grpc.RouteNote.location)
  return location_;
}
inline void RouteNote::set_allocated_location(::grpc::Point* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete location_;
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:grpc.RouteNote.location)
}

// string message = 2;
inline void RouteNote::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RouteNote::message() const {
  // @@protoc_insertion_point(field_get:grpc.RouteNote.message)
  return message_.GetNoArena();
}
inline void RouteNote::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:grpc.RouteNote.message)
}
#if LANG_CXX11
inline void RouteNote::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:grpc.RouteNote.message)
}
#endif
inline void RouteNote::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:grpc.RouteNote.message)
}
inline void RouteNote::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:grpc.RouteNote.message)
}
inline ::std::string* RouteNote::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:grpc.RouteNote.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RouteNote::release_message() {
  // @@protoc_insertion_point(field_release:grpc.RouteNote.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RouteNote::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:grpc.RouteNote.message)
}

// -------------------------------------------------------------------

// Alert

// string message = 1;
inline void Alert::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Alert::message() const {
  // @@protoc_insertion_point(field_get:grpc.Alert.message)
  return message_.GetNoArena();
}
inline void Alert::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:grpc.Alert.message)
}
#if LANG_CXX11
inline void Alert::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:grpc.Alert.message)
}
#endif
inline void Alert::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:grpc.Alert.message)
}
inline void Alert::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:grpc.Alert.message)
}
inline ::std::string* Alert::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:grpc.Alert.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Alert::release_message() {
  // @@protoc_insertion_point(field_release:grpc.Alert.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Alert::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:grpc.Alert.message)
}

// -------------------------------------------------------------------

// Mode

// string newMode = 1;
inline void Mode::clear_newmode() {
  newmode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Mode::newmode() const {
  // @@protoc_insertion_point(field_get:grpc.Mode.newMode)
  return newmode_.GetNoArena();
}
inline void Mode::set_newmode(const ::std::string& value) {
  
  newmode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:grpc.Mode.newMode)
}
#if LANG_CXX11
inline void Mode::set_newmode(::std::string&& value) {
  
  newmode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:grpc.Mode.newMode)
}
#endif
inline void Mode::set_newmode(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  newmode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:grpc.Mode.newMode)
}
inline void Mode::set_newmode(const char* value, size_t size) {
  
  newmode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:grpc.Mode.newMode)
}
inline ::std::string* Mode::mutable_newmode() {
  
  // @@protoc_insertion_point(field_mutable:grpc.Mode.newMode)
  return newmode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mode::release_newmode() {
  // @@protoc_insertion_point(field_release:grpc.Mode.newMode)
  
  return newmode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mode::set_allocated_newmode(::std::string* newmode) {
  if (newmode != NULL) {
    
  } else {
    
  }
  newmode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), newmode);
  // @@protoc_insertion_point(field_set_allocated:grpc.Mode.newMode)
}

// -------------------------------------------------------------------

// Temp

// uint32 newTemp = 1;
inline void Temp::clear_newtemp() {
  newtemp_ = 0u;
}
inline ::google::protobuf::uint32 Temp::newtemp() const {
  // @@protoc_insertion_point(field_get:grpc.Temp.newTemp)
  return newtemp_;
}
inline void Temp::set_newtemp(::google::protobuf::uint32 value) {
  
  newtemp_ = value;
  // @@protoc_insertion_point(field_set:grpc.Temp.newTemp)
}

// -------------------------------------------------------------------

// Topic

// string clientName = 1;
inline void Topic::clear_clientname() {
  clientname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Topic::clientname() const {
  // @@protoc_insertion_point(field_get:grpc.Topic.clientName)
  return clientname_.GetNoArena();
}
inline void Topic::set_clientname(const ::std::string& value) {
  
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:grpc.Topic.clientName)
}
#if LANG_CXX11
inline void Topic::set_clientname(::std::string&& value) {
  
  clientname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:grpc.Topic.clientName)
}
#endif
inline void Topic::set_clientname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:grpc.Topic.clientName)
}
inline void Topic::set_clientname(const char* value, size_t size) {
  
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:grpc.Topic.clientName)
}
inline ::std::string* Topic::mutable_clientname() {
  
  // @@protoc_insertion_point(field_mutable:grpc.Topic.clientName)
  return clientname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Topic::release_clientname() {
  // @@protoc_insertion_point(field_release:grpc.Topic.clientName)
  
  return clientname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Topic::set_allocated_clientname(::std::string* clientname) {
  if (clientname != NULL) {
    
  } else {
    
  }
  clientname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientname);
  // @@protoc_insertion_point(field_set_allocated:grpc.Topic.clientName)
}

// .grpc.topicType type = 2;
inline void Topic::clear_type() {
  type_ = 0;
}
inline ::grpc::topicType Topic::type() const {
  // @@protoc_insertion_point(field_get:grpc.Topic.type)
  return static_cast< ::grpc::topicType >(type_);
}
inline void Topic::set_type(::grpc::topicType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:grpc.Topic.type)
}

// -------------------------------------------------------------------

// Notification

// string clientName = 1;
inline void Notification::clear_clientname() {
  clientname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Notification::clientname() const {
  // @@protoc_insertion_point(field_get:grpc.Notification.clientName)
  return clientname_.GetNoArena();
}
inline void Notification::set_clientname(const ::std::string& value) {
  
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:grpc.Notification.clientName)
}
#if LANG_CXX11
inline void Notification::set_clientname(::std::string&& value) {
  
  clientname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:grpc.Notification.clientName)
}
#endif
inline void Notification::set_clientname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:grpc.Notification.clientName)
}
inline void Notification::set_clientname(const char* value, size_t size) {
  
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:grpc.Notification.clientName)
}
inline ::std::string* Notification::mutable_clientname() {
  
  // @@protoc_insertion_point(field_mutable:grpc.Notification.clientName)
  return clientname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Notification::release_clientname() {
  // @@protoc_insertion_point(field_release:grpc.Notification.clientName)
  
  return clientname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Notification::set_allocated_clientname(::std::string* clientname) {
  if (clientname != NULL) {
    
  } else {
    
  }
  clientname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientname);
  // @@protoc_insertion_point(field_set_allocated:grpc.Notification.clientName)
}

// string serverName = 2;
inline void Notification::clear_servername() {
  servername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Notification::servername() const {
  // @@protoc_insertion_point(field_get:grpc.Notification.serverName)
  return servername_.GetNoArena();
}
inline void Notification::set_servername(const ::std::string& value) {
  
  servername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:grpc.Notification.serverName)
}
#if LANG_CXX11
inline void Notification::set_servername(::std::string&& value) {
  
  servername_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:grpc.Notification.serverName)
}
#endif
inline void Notification::set_servername(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  servername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:grpc.Notification.serverName)
}
inline void Notification::set_servername(const char* value, size_t size) {
  
  servername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:grpc.Notification.serverName)
}
inline ::std::string* Notification::mutable_servername() {
  
  // @@protoc_insertion_point(field_mutable:grpc.Notification.serverName)
  return servername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Notification::release_servername() {
  // @@protoc_insertion_point(field_release:grpc.Notification.serverName)
  
  return servername_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Notification::set_allocated_servername(::std::string* servername) {
  if (servername != NULL) {
    
  } else {
    
  }
  servername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), servername);
  // @@protoc_insertion_point(field_set_allocated:grpc.Notification.serverName)
}

// .grpc.topicType type = 3;
inline void Notification::clear_type() {
  type_ = 0;
}
inline ::grpc::topicType Notification::type() const {
  // @@protoc_insertion_point(field_get:grpc.Notification.type)
  return static_cast< ::grpc::topicType >(type_);
}
inline void Notification::set_type(::grpc::topicType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:grpc.Notification.type)
}

// .grpc.Alert a = 6;
inline bool Notification::has_a() const {
  return this != internal_default_instance() && a_ != NULL;
}
inline void Notification::clear_a() {
  if (GetArenaNoVirtual() == NULL && a_ != NULL) {
    delete a_;
  }
  a_ = NULL;
}
inline const ::grpc::Alert& Notification::a() const {
  const ::grpc::Alert* p = a_;
  // @@protoc_insertion_point(field_get:grpc.Notification.a)
  return p != NULL ? *p : *reinterpret_cast<const ::grpc::Alert*>(
      &::grpc::_Alert_default_instance_);
}
inline ::grpc::Alert* Notification::release_a() {
  // @@protoc_insertion_point(field_release:grpc.Notification.a)
  
  ::grpc::Alert* temp = a_;
  a_ = NULL;
  return temp;
}
inline ::grpc::Alert* Notification::mutable_a() {
  
  if (a_ == NULL) {
    a_ = new ::grpc::Alert;
  }
  // @@protoc_insertion_point(field_mutable:grpc.Notification.a)
  return a_;
}
inline void Notification::set_allocated_a(::grpc::Alert* a) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete a_;
  }
  if (a) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      a = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, a, submessage_arena);
    }
    
  } else {
    
  }
  a_ = a;
  // @@protoc_insertion_point(field_set_allocated:grpc.Notification.a)
}

// .grpc.Mode m = 4;
inline bool Notification::has_m() const {
  return this != internal_default_instance() && m_ != NULL;
}
inline void Notification::clear_m() {
  if (GetArenaNoVirtual() == NULL && m_ != NULL) {
    delete m_;
  }
  m_ = NULL;
}
inline const ::grpc::Mode& Notification::m() const {
  const ::grpc::Mode* p = m_;
  // @@protoc_insertion_point(field_get:grpc.Notification.m)
  return p != NULL ? *p : *reinterpret_cast<const ::grpc::Mode*>(
      &::grpc::_Mode_default_instance_);
}
inline ::grpc::Mode* Notification::release_m() {
  // @@protoc_insertion_point(field_release:grpc.Notification.m)
  
  ::grpc::Mode* temp = m_;
  m_ = NULL;
  return temp;
}
inline ::grpc::Mode* Notification::mutable_m() {
  
  if (m_ == NULL) {
    m_ = new ::grpc::Mode;
  }
  // @@protoc_insertion_point(field_mutable:grpc.Notification.m)
  return m_;
}
inline void Notification::set_allocated_m(::grpc::Mode* m) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete m_;
  }
  if (m) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      m = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, m, submessage_arena);
    }
    
  } else {
    
  }
  m_ = m;
  // @@protoc_insertion_point(field_set_allocated:grpc.Notification.m)
}

// .grpc.Temp t = 5;
inline bool Notification::has_t() const {
  return this != internal_default_instance() && t_ != NULL;
}
inline void Notification::clear_t() {
  if (GetArenaNoVirtual() == NULL && t_ != NULL) {
    delete t_;
  }
  t_ = NULL;
}
inline const ::grpc::Temp& Notification::t() const {
  const ::grpc::Temp* p = t_;
  // @@protoc_insertion_point(field_get:grpc.Notification.t)
  return p != NULL ? *p : *reinterpret_cast<const ::grpc::Temp*>(
      &::grpc::_Temp_default_instance_);
}
inline ::grpc::Temp* Notification::release_t() {
  // @@protoc_insertion_point(field_release:grpc.Notification.t)
  
  ::grpc::Temp* temp = t_;
  t_ = NULL;
  return temp;
}
inline ::grpc::Temp* Notification::mutable_t() {
  
  if (t_ == NULL) {
    t_ = new ::grpc::Temp;
  }
  // @@protoc_insertion_point(field_mutable:grpc.Notification.t)
  return t_;
}
inline void Notification::set_allocated_t(::grpc::Temp* t) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete t_;
  }
  if (t) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      t = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }
    
  } else {
    
  }
  t_ = t;
  // @@protoc_insertion_point(field_set_allocated:grpc.Notification.t)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace grpc

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::grpc::topicType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::grpc::topicType>() {
  return ::grpc::topicType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_test_2eproto__INCLUDED
